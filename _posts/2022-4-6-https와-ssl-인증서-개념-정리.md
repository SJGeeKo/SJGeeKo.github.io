---
layout: post
title: HTTPS와 SSL 인증서 개념 정리
---

참고: [생활코딩](https://opentutorials.org/course/228/4894)

- HTTPS는 보안 강화된 HTTP임
- HTTPS와 SSL의 관계
    - SSL 프로토콜 위에서 위에서 HTTPS 프로토콜이 동작하는 것
    - 참고로 SSL과 TSL은 동의어라고 봐도 무방

### SSL 인증서의 역할

---

1. 통신 내용이 **노출되지 않도록** 막음
2. 클라이언트가 접속하려는 서버가 **신뢰할 수 있는 서버인지 판단하는 기준**
    1. 클라이언트에게 서버가 ‘내가 나 맞아!’ 하고 알려주는 용도
    2. 클라이언트가 서버에 접속 → 서버가 클라이언트에게 인증서 전달 → 너 맞구나? ㅇㅋ 순서로 동작.
3. 통신 내용의 악의적인 **변경 방지**

### SSL에서 사용하는 암호화 종류

---

- 위에서 SSL의 역할 중 하나가 ‘통신 내용이 노출되지 않도록 막음’이라고 했음. 즉, **암호화**가 된다는 뜻.
    - 암호화 중요 단어 간단 소개
    - 암호화: 어떤 데이터를 이해할 수 없는 데이터로 변경하는 것
    - 복호화: 암호화의 반대
    - KEY: 암호화와 복호화의 기준이 되는 데이터(말 그대로 열쇠)
        - 즉, 이것이 있어야 어떤 데이터로 암호화 하거나 암호화된 데이터를 복호화 할 수 있는 것.
- SSL을 이해하기 위해서는 암호화 종류 중 대칭키, 공개키를 먼저 이해할 필요가 있음.

**대칭키**

- 암호화하는 쪽과 복호화하는 쪽이 **동일한 키**를 갖고 있다는 의미에서 ‘대칭키'라고 명명함.
- EX: 암호화 하고 싶은 문자가 ‘ABC’임. 이 때 내가 임의로 대칭키를 ‘111111’로 설정하여 암호화 진행 → ‘ABC’가 알 수 없는 문자로 변환됨(예: ’aifgrqeuh’) → 대칭키 ‘111111’을 입력하여 복호화 진행 → 다시 ‘ABC’로 변환되는 방식
- 단점
    - 키가 대칭키 하나뿐. 대칭키를 알게 되면 누구나 암호화한 정보를 복호화 할 수 있다 → **보안 강도가 낮다**

**공개키**

- 암호화하는 쪽과 복호화 하는 쪽이 **서로 다른 키**를 갖고 있다
    - A키로 암호화한 데이터는 B키로만 복호화 가능, B키로 암호화한 데이터는 A키로만 복호화 가능
- 둘 중 하나를 **공개키(public key)**로 지정하고, 나머지 하나를 **비밀키(private key)**로 지정한다.
- **비밀키는 나(서버)만 갖고 공개키는 누구나 받을 수 있도록** 공유한다.
- 공개키를 공유받은 **타인(들)은 공개키를 이용해 암호화**한 뒤 데이터 통신을 진행한다
    - 어차피 비밀키는 나만 갖고 있으니 공개키를 갖고 있는 다른 사람이 타인의 데이터를 복호화하는 것은 불가능
    - 그렇기 때문에 애초에 공개키는 누구나 다운받을 수 있게 해둬도 문제 없는 것
- 공개키를 데이터 제공한 쪽(서버)의 신원보장에도 사용할 수 있음
    - 서버가 비밀키로 특정 데이터 암호화 → 암호화된 데이터와 공개키를 함께 클라이언트에게 전달 → 클라이언트는 공개키로 암호화된 데이터 복호화 → 복호화 잘 되네? 서버가 제대로된 비밀키로 암호화해서 나한테 데이터를 전달했네? → 이 서버 믿을 수 있겠다
        - 암호화된 데이터와 공개키를 함께 전달하기 때문에 누구나 중간에 해당 데이터 가로채면 복호화 가능하긴 함
        - 그러나 애초에 이런 통신의 목적은 **서버가 ㄹㅇ임을 알려주는 것**이라 문제 없음.
        - 이러한 방식을 **전자서명**이라고 함(서명이 내가 나임을 증명하는 것이니 이렇게 명명한듯?)
- 비밀키와 공개키의 확장자는 `.pem`, 키의 길이를 커스텀할 수 있음.
    - 공개키는 비밀키를 먼저 만든 뒤 해당 비밀키를 이용하여 만들 수 있다.

## SSL 인증서

---

- 본격적으로 SSL 인증서에 대해 알아보자.
- 인증서의 기능은 두 가지
    - 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장
    - SSL 통신에 사용할 공개키를 클라이언트에게 제공
- 인증서의 내용
    - 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 ...)
    - 서버측 공개키(공개키의 내용, 공개키의 암호화 방법)

### CA(Certificate authority)

- 어떤 사이트를 신뢰할 수 있는지 보증해주는 기업들을 말하며, Symantec, Comodo, GoDaddy, GlobalSign 등의 기업이 이에 해당
- **웹브라우저**는 이러한 **기업들의 목록**과 각 기업들의 **공개키를 갖고 있음**.
- SSL을 통해서 암호화된 통신을 제공하려면 CA를 통해 **인증서를 구입해야 함**.
    - 무료로 사용하는 방법도 있으니 걱정 ㄴㄴ
    - 구입하는 과정에서 CA가 서비스에 대한 여러 가지 정보를 요구하게 됨. 이들은 인증기관이기 때문에 수상한 서비스인지 아닌지를 자신들의 기준으로 판단해주는 것.
    - 서비스는 비밀키와 공개키를 생성하고 CA에 공개키와 위 정보를 함께 넘기게 됨
    - 이후 CA에서 검사 후 SSL 인증서를 발급해주면 그 다음부터는 서버가 해당 인증서를 클라이언트에게 전달함으로써 HTTPS 통신이 가능해진다.

### 인증서 동작방법

1. 클라이언트가 서버에 접속
2. 서버가 클라이언트에게 SSL인증서 전달
3. 클라이언트는 해당 인증서 까서 이 인증서를 보증해준 CA가 어디인지 확인
4. 자신이 갖고 있는 CA 목록에 해당 CA가 있는지 확인
5. 있다면 클라이언트가 갖고 있는 해당 CA의 공개키로 인증서 복호화 시도함
    
    <aside>
    💡  클라이언트(웹브라우저)는 믿을 만한 CA의 목록과 공개키를 갖고 있다
    
    </aside>
    
6. 복호화 성공했다? 그럼 해당 인증서는 그 CA가 갖고 있는 비밀키를 이용해 암호화 됐다는 의미
    1. 즉, 해당 CA가 이 서버가 안전함을 보장해줬다는 의미 → 굳 안전하네 통신하자 ㄱㄱ

### SSL의 동작방법

- 보안상 가장 이상적인 것은 모든 데이터 통신을 공개키 방식으로 하는 것.
- 그러나 성능을 많이 잡아먹는다는 단점이 있음
- 따라서 SSL은 공개키와 대칭키를 혼합하여 사용하는 방식으로 동작한다.
    - 실제 데이터: 대칭키 사용
    - 대칭키의 키: 공개키 사용
- ‘악수(Handshake) → 전송 → 세션종료’의 순서로 동작

**악수(Handshake) -** 클라이언트와 서버가 서로 신뢰를 얻는 과정

1. 클라이언트가 서버에 처음 접근함
    - “Server hello”
2. 서버가 클라이언트의 정보를 확인하고 암호화 방식 등을 결정한 뒤 서버의 인증서를 보냄
3. 클라이언트가 인증서를 확인하여 서버가 CA에 의해 검증된 곳임을 확인함(수상한 서버는 아니군 ㅇㅇ)
4. 클라이언트가 대칭키를 생성함
5. 서버에서 받은 인증서에 포함된 공개키를 이용하여 암호화 후 서버에 대칭키 전송
    - 대칭키는 털리면 큰일남. 따라서 이를 안전하게 보내기 위해 서버에서 받은 공개키를 이용하는 것.
    - 그에 맞는 비밀키를 갖고 있는 사람 말고는 복호화 못하므로 매우 안전!
6. 서버는 이를 다시 자신의 비밀키로 복호화
7. 클라이언트와 서버가 일련의 과정을 거친 뒤 동일한 session key를 갖게 됨 → 이제부터 서로 대칭키 방식으로 암호화, 복호화하여 데이터 통신 가능!
8. 악수 종료

**전송(세션)**

- 위 과정에서 만들어진 session key를 이용하여 대칭키 방식으로 데이터를 통신함

**세션종료**

- SSL 통신이 끝났음을 알림. 이 통신을 위해 사용된 session key는 폐기됨
    - 같은 key를 계속 사용한다면 보안상 좋지 않으므로 쓰고 버리는 것.
